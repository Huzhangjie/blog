---
title: 二分查找
tags:
  - 搜索算法
  - 二分查找
  - 算法题
categories: 算法
cover: /images/日系-路牌.jpg
date: 2021-10-12 15:32:42
---

# 二分查找

## 基础知识
二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用`顺序存储结构`，而且表中元素按`关键字有序排列`

### 要求
1. 必须采用顺序存储结构
2. 必须按关键字大小有序排列

### 复杂度
`时间复杂度`: O(logn) 
`空间复杂度`: O(log2n) 

### 技巧
1. 记录当前数组`nums`的左右指针`left`, `right`
2. `while` 循环比较 `left < right`
  - 循环中取中间下标 `mid = left + right >> 1`
  - 判断中间变量和两侧的大小关系
  - 操作 `left = mid - 1` || `right = mid + 1`
  - 找到值直到退出循环


## 题目
### 搜索插入位置（ LeetCode 35 ）
[leetcode](https://leetcode-cn.com/problems/search-insert-position/)
> 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
>
> 请必须使用时间复杂度为 O(log n) 的算法。

```js
// 二分法查找
var searchInsert = function(nums, target) {
  const len = nums.length
  let left = 0, right = n - 1
  
  // 最后要返回的结果
  let ans = len

  while(left <= right) {
    // 取中间值
    const mid = left + right >> 1

    // 中间位置的数大于 target
    // 右侧的数都大于 target, 则将right 变为 mid - 1
    if(nums[mid] >= target) {
      ans = mid
      right = mid - 1
    } else {
      // 中间数小于 target
      // 左侧的数都小于 target, left = mid + 1
      left = mid + 1
    }
  }
  return ans
}
```

### 在排序数组中查找元素的第一个和最后一个位置（ LeetCode 34 ）
[leetcode](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)
> 给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。
> 如果数组中不存在目标值 target，返回 [-1, -1]。
>
> 进阶：你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？

```ts
// 时间复杂度为 O(log n)
// 第一时间应该想到使用二分法查找
function searchRange(nums: number[], target: number): number[] {
  const firstIdx = findBeginIndex(nums, target)
  const endIdx = findEndIndex(nums, target)

  return [firstIdx, endIdx]
};

// 寻找数组中目标元素的第一个下标
function findBeginIndex (nums: number[], target: number): number {
  let left = 0
  let right = nums.length

  // 进行二分查找
  while(left <= right) {
    // 取中间下标
    let mid = left + right >> 1

    // 中间元素等于 目标元素相等
    if(nums[mid] === target) {
      // 中间元素的前一个元素 < 目标元素
      // 找到正确的开始位置
      if(mid === 0 || nums[mid - 1] < target) {
        return mid
      }

      // 否则，开始位置在mid的左侧，继续二分查找mid 的左侧部分
      // 修改 right 的位置，继续查找
      right = mid - 1

    } else if(nums[mid] > target) {
      // 中间元素 > 目标元素
      // 目标元素在 mid 左侧
      
      right = mid - 1
    } else {
      // 中间元素 < 目标元素
      // 目标元素在 mid 右侧
      left = mid + 1
    }
  } 

  // 如果循环结束后还没有返回，说明找不到目标值 target，返回 -1
  return -1
}

// 寻找数组中目标元素中的最后一个的下标
// 和上面寻找开始下标的方法只是在 判断中间值时不同
function findEndIndex (nums: number[], target: number): number {
  let left = 0
  let right = nums.length

  while(left <= right) {
    let mid = left + right >> 1

    if(nums[mid] === target) {
      if(mid === nums.length - 1 || nums[mid + 1] > target) {
        return mid
      }
      left = mid + 1
    } else if(nums[mid] > target) {
      right = mid - 1
    } else {
      left = mid + 1
    }
  } 

  return -1
}

```

#### 抖个机灵
```ts
// 使用 js Array 自带的方法实现
function searchRange(nums: number[], target: number): number[] {
  const firstIdx = nums.findIndex(num => num === target)
  const endIdx = nums.lastIndexOf(target)

  return [firstIdx, endIdx]
};

```

### 搜索旋转排序数组（ LeetCode 33 ）
[leetcode](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)
> 整数数组 nums 按升序排列，数组中的值 互不相同 。
>
> 在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。
>
> 给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。

```ts
function search(nums: number[], target: number): number {
  let left = 0
  let right = nums.length - 1

  // 先二分查找出 
  // nums[mid] > flag && nums[mid + 1] < flag 时的 mid的位置
  // 表明 mid 这个位置的元素是最大的，mid之后的元素都是被反转过得
  // 则 k = nums.length - mid - 1 
  while(left <= right) {
    const mid = right + left >> 1
    // 成功找到了 target 
    if(nums[mid] === target) return mid

    // 否则先确定 mid 是左边还是右边有序

    // 左侧部分有序
    if(nums[left] <= nums[mid]) {
      // 判断 target 在有序部分(左) 还是在 无序部分(右)
      if(target >= nums[left] && target <= nums[mid]) {
        // target在左侧部分
        right = mid - 1
      } else {
        left = mid + 1
      }
    } else {
      // mid左侧为无序，右侧有序

      // 判断 target是否在有序空间(右)
      if(target >= nums[mid] && target <= nums[right]) {
        // 在右侧
        left = mid + 1
      } else {
        right = mid - 1
      }
    }
  }

  return -1
};
```

